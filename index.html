<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <title>Compile Card Database</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
</head>

<body>
    <div class="navbar-fixed">
        <nav>
            <div class="nav-wrapper header">
                <img src="img/compile.png" alt="Compile">
                <span>Card Database</span>
                <ul class="right">
                    <li><a data-target="filters" class="modal-trigger"><i
                                class="material-icons left">filter_alt</i>Filter Cards</a>
                        <span id="active-filters-count" class="badge"></span>
                    </li>
                    <li><a id="clear-filters"><i class="material-icons left">refresh</i>Clear Filters</a></li>
                </ul>
            </div>
        </nav>
    </div>

    <div id="filters" class="modal filter-options modal-fixed-footer modal-fixed-header">
        <div class="modal-header">
            Filters
        </div>        
        <div class="modal-content">
            <form id="filter-form">
                
                <fieldset class="filter-group">
                    <legend>Set</legend>
                    <div id="sets-filter">
                        <!-- Checkboxes will be dynamically inserted here -->
                    </div>
                </fieldset>
                
                <fieldset class="filter-group">
                    <legend>Value</legend>
                    <div id="value-filter">
                        <!-- Checkboxes will be dynamically inserted here -->
                    </div>
                </fieldset>

                <fieldset class="filter-group">
                    <legend>Protocol</legend>
                    <div id="protocol-filter">
                        <!-- Checkboxes will be dynamically inserted here -->
                    </div>
                </fieldset>

                <fieldset class="filter-group">
                    <legend>Keyword</legend>
                    <div id="keyword-filter">
                        <!-- Checkboxes will be dynamically inserted here -->
                    </div>
                </fieldset>

            </form>
        </div>
        <div class="modal-footer">
            <a href="#!" class="modal-close btn">Close</a>
        </div>
    </div>


    <div class="container">
        <ul id="protocolList" class="collapsible popout"></ul>
        <div id="content"></div>
    </div>


    <div class="fixed-action-btn">
        <a class="btn-floating btn-large blue">
            <i class="large material-icons">mode_edit</i>
        </a>
        <ul>
            <li><a id="btn-group" class="btn-floating green" title="Group by Protocol"><i
                        class="material-icons">group</i></a></li>
            <li><a id="btn-ungroup" class="btn-floating red" title="Remove Protocol Grouping"><i
                        class="material-icons">group_remove</i></a></li>
        </ul>
    </div>


    <script>
        // Using a set to store unique values for each category from the data to prevent hardcoding values.
        let uniqueProtocols = new Set();
        let uniqueValues = new Set();
        let uniqueKeywords = new Set();
        let uniqueSets = new Set();
        let data;
        let groupProtocolDataToggle = true; // default to grouping the data by protocol

        $(document).ready(function () {
            $.getJSON('cards.json', function (response) {
                console.log("Data loaded successfully");
                // make sure the filter lists are cleared out before adding new data. 
                uniqueProtocols.clear();
                uniqueValues.clear();
                uniqueKeywords.clear();
                uniqueSets.clear();

                data = response;

                data.forEach(function (item) {
                    uniqueProtocols.add(item.protocol.trim().toLowerCase());
                    uniqueValues.add(Number(item.value));
                    if (item.keywords) {
                        Object.keys(item.keywords).forEach(function (keyword) {
                            uniqueKeywords.add(keyword.trim().toLowerCase());
                        });
                    }
                    uniqueSets.add(item.set.toLowerCase());
                });

                let protocolsArray = Array.from(uniqueProtocols);
                let valuesArray = Array.from(uniqueValues);
                let keywordsArray = Array.from(uniqueKeywords);
                let setsArray = Array.from(uniqueSets);

                setupFilters(protocolsArray, valuesArray, keywordsArray, setsArray);

                const compressedState = getCompressedStateFromURL();
                if (compressedState) {
                    applyStateFromCompressedString(compressedState);
                } else {
                    const queryParams = getQueryParams();
                    if (queryParams.hasFilters) {
                        const filters = constructFiltersFromQueryParams(queryParams);
                        applyFiltersFromState(filters);
                    } else {
                        displayData(data);
                    }
                }

                $('#protocolList').collapsible();
                $('.modal').modal();
                $('#clear-filters').on('click', function () {
                    clearFilters();
                });
                $('#btn-group').on('click', function () {
                    toggleGroupByProtocol(true);
                });
                $('#btn-ungroup').on('click', function () {
                    toggleGroupByProtocol(false);
                });
                $('.fixed-action-btn').floatingActionButton();
            }).fail(function (jqxhr, textStatus, error) {
                console.error("Failed to load card data: " + textStatus + ", " + error);
            });
        });

        const tooltipTexts = {
            'top': 'Persistent: While this card is face-up, this passive text is never covered.',
            'middle': 'Immediate: Resolve this active text upon card play/flip/uncover.',
            'bottom': 'Auxiliary: This passive text is often, but not limited to, triggered effects, but is only viable when uncovered',
        };

        // Using a helper function to get the tooltip text based on the type in case functionality needs to be expanded later
        function getTooltipText(toolTipType) {
            return tooltipTexts[toolTipType] || '';
        }

        function createCheckbox(name, value, labelText) {
            let checkboxId = `${name}-${value}`.replace(/\s+/g, '-').toLowerCase();
            let checkbox = $(`
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="${checkboxId}" name="${name}" value="${value}">
                    <label for="${checkboxId}">${labelText}</label>
                </div>
            `);
            return checkbox;
        }

        function setupFilters(protocols, values, keywords, sets) {

            let protocolContainer = $('#protocol-filter');
            protocols.sort().forEach(function (protocol) {
                let checkbox = createCheckbox('protocol', protocol, protocol);
                protocolContainer.append(checkbox);
            });

            let valueContainer = $('#value-filter');
            values.sort((a, b) => a - b).forEach(function (value) {
                let checkbox = createCheckbox('value', value, value);
                valueContainer.append(checkbox);
            });

            let keywordContainer = $('#keyword-filter');
            keywords.sort().forEach(function (keyword) {
                let checkbox = createCheckbox('keyword', keyword, keyword);
                keywordContainer.append(checkbox);
            });

            let setsContainer = $('#sets-filter');
            sets.sort().forEach(function (set) {
                let checkbox = createCheckbox('set', set, set);
                setsContainer.append(checkbox);
            });

            $('#filter-form').on('change', 'input[type="checkbox"]', function () {
                applyFilters();
            });
        }

        function applyFilters() {
            let selectedProtocols = $('#protocol-filter input[name="protocol"]:checked').map(function () {
                return $(this).val();
            }).get();
            console.log('Selected Protocols:', selectedProtocols);

            let selectedValues = $('#value-filter input[name="value"]:checked').map(function () {
                return $(this).val();
            }).get();
            console.log('Selected Values:', selectedValues);

            let selectedKeywords = $('#keyword-filter input[name="keyword"]:checked').map(function () {
                return $(this).val();
            }).get();
            console.log('Selected Keywords:', selectedKeywords);

            let selectedSets = $('#sets-filter input[name="set"]:checked').map(function () {
                return $(this).val();
            }).get();
            console.log('Selected Sets:', selectedSets);

            const filters = {
                protocols: selectedProtocols,
                values: selectedValues,
                keywords: selectedKeywords,
                sets: selectedSets,
                groupByProtocol: groupProtocolDataToggle,
            };

            const isDefaultState =
                selectedProtocols.length === 0 &&
                selectedValues.length === 0 &&
                selectedKeywords.length === 0 &&
                selectedSets.length === 0 &&
                groupProtocolDataToggle === true; // Assuming true is the default value

            if (isDefaultState) {
                // No filters applied, remove 'state' parameter from URL
                updateURLWithCompressedState(null);
            } else {
                const serializedFilters = serializeFilters(filters);
                const compressedState = compressString(serializedFilters);
                updateURLWithCompressedState(compressedState);
            }

            let filteredData = data.filter(function (item) {
                let matchesProtocol = true;
                let matchesValue = true;
                let matchesKeyword = true;
                let matchesSet = true;

                if (selectedProtocols.length > 0) {
                    matchesProtocol = selectedProtocols.includes(item.protocol.toLowerCase());
                }

                if (selectedValues.length > 0) {
                    matchesValue = selectedValues.includes(item.value.toString());
                }

                if (selectedKeywords.length > 0) {
                    matchesKeyword = selectedKeywords.some(function (kw) {
                        return item.keywords && item.keywords[kw];
                    });
                }

                if (selectedSets.length > 0) {
                    matchesSet = selectedSets.includes(item.set.toLowerCase());
                }

                return matchesProtocol && matchesValue && matchesKeyword && matchesSet;
            });

            displayData(filteredData);
            updateActiveFiltersCount();
        }

        function clearFilters() {
            $('#filter-form input[type="checkbox"]').prop('checked', false).trigger('change');
            applyFilters();
        }

        function updateActiveFiltersCount() {
            let count = 0;

            count += $('#protocol-filter input[name="protocol"]:checked').length;
            count += $('#value-filter input[name="value"]:checked').length;
            count += $('#keyword-filter input[name="keyword"]:checked').length;
            count += $('#sets-filter input[name="set"]:checked').length;

            $('#active-filters-count').text(count === 0 ? '' : count);
        }

        function toggleGroupByProtocol(group) {
            groupProtocolDataToggle = group;
            applyFilters();
        }

        function displayData(data) {
            var tooltipElements = document.querySelectorAll('.tooltipped');
            var tooltipInstances = M.Tooltip.getInstance(tooltipElements);
            if (tooltipInstances) {
                tooltipInstances.destroy();
            }

            let groupedData = groupProtocolDataToggle ? groupByProtocol(data) : data;
            let contentDiv = $('#content');
            let contentUL = $('#protocolList');

            contentDiv.empty();
            contentUL.empty();

            if (groupProtocolDataToggle === false) {
                // Handle ungrouped data
                let rowDiv = $('<div>').addClass('row');

                $.each(groupedData, function (index, item) {
                    let card = createCard(item);
                    rowDiv.append(card);
                });

                contentUL.append(rowDiv);
            } else {
                $.each(groupedData, function (protocol, items) {
                    let protocolList = $('<li>');
                    let protocolClass = sanitizeProtocolName(protocol.toLowerCase());
                    let protocolHeader = $('<div>').addClass('protocol-header collapsible-header ' + protocolClass).text(protocol);
                    protocolHeader.append($('<span>').addClass('badge').text(items.length));
                    protocolList.append(protocolHeader);

                    let protocolRow = $('<div>').addClass('collapsible-body');
                    let rowDiv = $('<div>').addClass('row');

                    $.each(items, function (index, item) {
                        let card = createCard(item);
                        rowDiv.append(card);
                    });

                    protocolRow.append(rowDiv);
                    protocolList.append(protocolRow);
                    contentUL.append(protocolList);
                });
            }
        }

        function groupByProtocol(data) {
            let grouped = {};
            data.forEach(function (item) {
                let protocol = item.protocol || 'Unknown';
                if (!grouped[protocol]) {
                    grouped[protocol] = [];
                }
                grouped[protocol].push(item);
            });
            return grouped;
        }

        function createCardSection(sectionData, sectionType) {
            if (sectionData && sectionData.text) {
                let emphasisText = sectionData.emphasis ? '<span class="emphasis">' + sectionData.emphasis + '</span> ' : '';
                let toolTipText = getTooltipText(sectionType);
                let section = $('<div>')
                    .addClass('card-section has-background tooltipped')
                    .attr('data-tooltip', toolTipText)
                    .html(emphasisText + sectionData.text);
                section.tooltip();
                return section;
            } else {
                let section = $('<div>')
                    .addClass('card-section blank-section')
                    .text('');
                return section;
            }
        }

        function createCard(item) {
            let colDiv = $('<div>').addClass('col');
            let protocolClass = sanitizeProtocolName(item.protocol.toLowerCase());
            let cardDiv = $('<div>').addClass('card fixed-height-card ' + protocolClass);
            let cardContentDiv = $('<div>').addClass('card-content');
            let cardTitle = $('<div>').addClass('custom-card-title');
            let protocolDiv = $('<div>').addClass('protocol').text(item.protocol);
            let valueDiv = $('<div>').addClass('value').text(item.value);

            cardTitle.append(protocolDiv).append(valueDiv);
            cardContentDiv.append(cardTitle);

            let sectionWrapper = $('<div>').addClass('section-wrapper');

            sectionWrapper.append(createCardSection(item.top, 'top'));
            sectionWrapper.append(createCardSection(item.middle, 'middle'));
            sectionWrapper.append(createCardSection(item.bottom, 'bottom'));

            cardContentDiv.append(sectionWrapper);

            let setDiv = $('<div>').addClass('set-text').text(item.set.toUpperCase() || '');
            cardContentDiv.append(setDiv);

            cardDiv.append(cardContentDiv);
            colDiv.append(cardDiv);

            return colDiv;
        }

        function sanitizeProtocolName(protocol) {
            return protocol.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '');
        }

        function applyFiltersFromQueryParams(params) {
            if (params.protocols.length > 0) {
                $('#protocol-filter').val(params.protocols);
            }

            if (params.values.length > 0) {
                $('#value-filter').val(params.values);
            }

            if (params.keywords.length > 0) {
                $('#keyword-filter').val(params.keywords);
            }

            if (params.sets.length > 0) {
                $('#sets-filter').val(params.sets);
            }
            $('select').formSelect();
        }

        function updateUIWithFilters(params) {
            applyFilters();
            if (params.groupByProtocol !== null) {
                groupProtocolDataToggle = params.groupByProtocol === 'true';
            }
        }

        function updateURLWithFilters(filters) {
            const url = new URL(window.location.href);

            url.searchParams.delete('protocol');
            url.searchParams.delete('value');
            url.searchParams.delete('keyword');
            url.searchParams.delete('set');
            url.searchParams.delete('groupByProtocol');

            filters.protocols.forEach(protocol => {
                url.searchParams.append('protocol', protocol);
            });

            filters.values.forEach(value => {
                url.searchParams.append('value', value);
            });

            filters.keywords.forEach(keyword => {
                url.searchParams.append('keyword', keyword);
            });

            filters.sets.forEach(set => {
                url.searchParams.append('set', set);
            });

            url.searchParams.set('groupByProtocol', filters.groupByProtocol);

            window.history.replaceState({}, '', url);
        }

        function serializeFilters(filters) {
            return JSON.stringify(filters);
        }

        function compressString(str) {
            return LZString.compressToEncodedURIComponent(str);
        }

        function updateURLWithCompressedState(compressedState) {
            const url = new URL(window.location.href);
            url.searchParams.delete('protocol');
            url.searchParams.delete('value');
            url.searchParams.delete('keyword');
            url.searchParams.delete('set');
            url.searchParams.delete('groupByProtocol');
            url.searchParams.delete('state');
            if (compressedState) {
                url.searchParams.set('state', compressedState);
            }
            window.history.replaceState({}, '', url);
        }

        function getCompressedStateFromURL() {
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            const compressedState = urlParams.get('state');
            return compressedState;
        }

        function getQueryParams() {
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);

            const protocols = urlParams.getAll('protocol');
            const values = urlParams.getAll('value');
            const keywords = urlParams.getAll('keyword');
            const sets = urlParams.getAll('set');
            const groupByProtocol = urlParams.get('groupByProtocol');

            const hasFilters =
                protocols.length > 0 ||
                values.length > 0 ||
                keywords.length > 0 ||
                sets.length > 0 ||
                groupByProtocol !== null;

            return {
                protocols,
                values,
                keywords,
                sets,
                groupByProtocol,
                hasFilters
            };
        }

        function constructFiltersFromQueryParams(params) {
            const groupByProtocolFlag = params.groupByProtocol !== null ? params.groupByProtocol === 'true' : true;
            return {
                protocols: params.protocols || [],
                values: params.values || [],
                keywords: params.keywords || [],
                sets: params.sets || [],
                groupByProtocol: groupByProtocolFlag
            };
        }

        function decompressString(compressedStr) {
            return LZString.decompressFromEncodedURIComponent(compressedStr);
        }

        function applyStateFromCompressedString(compressedState) {
            try {
                const decompressedStr = decompressString(compressedState);
                const filters = JSON.parse(decompressedStr);
                applyFiltersFromState(filters);
            } catch (error) {
                console.error('Failed to apply state from URL:', error);
                const url = new URL(window.location.href); // remove invalid state from URL and display all data
                url.searchParams.delete('state');
                window.history.replaceState({}, '', url);
                displayData(data);
            }
        }

        function applyFiltersFromState(filters) {
            $('#protocol-filter').val(filters.protocols);
            $('#value-filter').val(filters.values);
            $('#keyword-filter').val(filters.keywords);
            $('#sets-filter').val(filters.sets);
            $('select').formSelect();

            groupProtocolDataToggle = filters.groupByProtocol;

            applyFilters();
        }


    </script>
</body>

</html>